This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-21T13:22:36.488Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.eslintrc.js
.gitignore
App.js
app.json
app/_layout.js
app/(auth)/_layout.js
app/(auth)/login.js
app/(auth)/sign-up.js
app/chat/[conversationId].js
app/index.js
app/new-chat.js
app/test-style.js
babel.config.js
context/AuthContext.js
globals.css
index.js
lib/appwrite.js
metro.config.js
package.json
plan.md
tailwind.config.js

================================================================
Repository Files
================================================================

================
File: .eslintrc.js
================
// https://docs.expo.dev/guides/using-eslint/
module.exports = {
  extends: 'expo',
  ignorePatterns: ['/dist/*'],
};

================
File: .gitignore
================
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local
.env

# typescript
*.tsbuildinfo

================
File: App.js
================
import "./globals.css";
// App.js is required by registerRootComponent in index.js
// but navigation/content is handled by Expo Router via the app/ directory.
// It can be used for global providers if needed, otherwise return null.

export default function App() {
  return null;
}

================
File: app.json
================
{
  "expo": {
    "name": "DDS_chatapp",
    "slug": "ddschatapp",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "newArchEnabled": true,
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      }
    },
    "web": {
      "bundler": "metro",
      "favicon": "./assets/favicon.png"
    },
    "owner": "larsallan",
    "plugins": [
      "expo-router",
      "expo-secure-store"
    ]
  }
}

================
File: app/_layout.js
================
import { Stack } from "expo-router";
import { AuthProvider, useAuth } from "../context/AuthContext";
import { ActivityIndicator, View, Text } from "react-native";
import { useEffect, useState } from "react";
import { useRouter, useSegments } from "expo-router";

// Component to show loading indicator
function LoadingScreen({ message = "Loading..." }) {
  return (
    <View style={{ flex: 1, justifyContent: "center", alignItems: "center" }}>
      <ActivityIndicator size="large" />
      <Text style={{ marginTop: 10 }}>{message}</Text>
    </View>
  );
}

// Root layout component that includes navigation logic
function RootLayoutNav() {
  const { user, isLoading: isAuthLoading } = useAuth();
  const segments = useSegments();
  const router = useRouter();

  useEffect(() => {
    if (isAuthLoading) return;

    const inAuthGroup = segments[0] === "(auth)";

    if (!user && !inAuthGroup) {
      router.replace("/login");
    } else if (user && inAuthGroup) {
      router.replace("/");
    }
  }, [user, segments, isAuthLoading, router]);

  if (isAuthLoading) {
    return <LoadingScreen message="Checking session..." />;
  }

  return (
    <Stack screenOptions={{ headerShown: false }}>
      {/* Screens defined here */}
    </Stack>
  );
}

// Main export wraps everything with the AuthProvider
export default function RootLayout() {
  return (
    <AuthProvider>
      <RootLayoutNav />
    </AuthProvider>
  );
}

================
File: app/(auth)/_layout.js
================
import { Stack } from "expo-router";
import React from "react";

// Simple layout for auth screens, could add shared headers/styles here later
export default function AuthLayout() {
  return <Stack screenOptions={{ headerShown: false }} />;
}

================
File: app/(auth)/login.js
================
import React, { useState } from "react";
import {
  View,
  Text,
  TextInput,
  Button,
  ActivityIndicator,
  Alert,
} from "react-native";
import { Link } from "expo-router";
import { SafeAreaView } from "react-native-safe-area-context";
import { useAuth } from "../../context/AuthContext";

// Placeholder for Login Screen
export default function LoginScreen() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const { login, isLoading, testAppwriteConnection } = useAuth();

  const handleLogin = async () => {
    if (!email || !password) {
      Alert.alert("Error", "Please enter both email and password.");
      return;
    }
    await login(email, password);
  };

  const handleTestConnection = async () => {
    Alert.alert("Testing Connection...", "Please wait.");
    const result = await testAppwriteConnection();
    Alert.alert(
      result.success ? "Connection Test Successful" : "Connection Test Failed",
      result.message
    );
  };

  return (
    <SafeAreaView className="flex-1 justify-center p-5">
      <Text className="text-2xl font-bold mb-5 text-center">Login</Text>
      <TextInput
        className="h-10 border border-gray-300 mb-3 px-2.5 rounded bg-white"
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />
      <TextInput
        className="h-10 border border-gray-300 mb-3 px-2.5 rounded bg-white"
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />
      {isLoading ? (
        <ActivityIndicator size="large" className="mt-2.5" />
      ) : (
        <View className="mb-2">
          <Button title="Login" onPress={handleLogin} />
        </View>
      )}
      <View className="mb-3">
        <Button
          title="Test Appwrite Connection"
          onPress={handleTestConnection}
          color="#841584"
        />
      </View>
      <Link href="/sign-up" className="mt-4 text-center text-blue-600">
        Don't have an account? Sign Up
      </Link>
    </SafeAreaView>
  );
}

================
File: app/(auth)/sign-up.js
================
import React, { useState } from "react";
import {
  View,
  Text,
  TextInput,
  Button,
  Alert,
  ActivityIndicator,
} from "react-native";
import { Link } from "expo-router";
import { SafeAreaView } from "react-native-safe-area-context";
import { useAuth } from "../../context/AuthContext";

// Placeholder for Sign Up Screen
export default function SignUpScreen() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [name, setName] = useState(""); // Optional: Collect user's name
  const { signup, isLoading } = useAuth();

  const handleSignUp = async () => {
    if (!email || !password) {
      Alert.alert("Error", "Please enter both email and password.");
      return;
    }
    await signup(email, password, name);
  };

  return (
    <SafeAreaView className="flex-1 justify-center p-5">
      <Text className="text-2xl font-bold mb-5 text-center">Sign Up</Text>
      <TextInput
        className="h-10 border border-gray-300 mb-3 px-2.5 rounded bg-white"
        placeholder="Name (Optional)"
        value={name}
        onChangeText={setName}
        autoCapitalize="words"
      />
      <TextInput
        className="h-10 border border-gray-300 mb-3 px-2.5 rounded bg-white"
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />
      <TextInput
        className="h-10 border border-gray-300 mb-3 px-2.5 rounded bg-white"
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />
      {isLoading ? (
        <ActivityIndicator size="large" className="mt-2.5" />
      ) : (
        <View className="mb-2">
          <Button title="Sign Up" onPress={handleSignUp} />
        </View>
      )}
      <Link href="/login" className="mt-4 text-center text-blue-600">
        Already have an account? Login
      </Link>
    </SafeAreaView>
  );
}

================
File: app/chat/[conversationId].js
================
import React, { useState, useEffect, useCallback, useRef } from "react";
import {
  View,
  Text,
  TextInput,
  Button,
  FlatList,
  ActivityIndicator,
  KeyboardAvoidingView,
  Platform,
  Alert,
} from "react-native";
import { useLocalSearchParams, Stack } from "expo-router";
import { SafeAreaView } from "react-native-safe-area-context";
import { useAuth } from "../../context/AuthContext";
import {
  databases,
  databaseId,
  client,
  messagesCollectionId,
  conversationsCollectionId,
  usersCollectionId,
} from "../../lib/appwrite";
import { Query, ID } from "appwrite";

export default function ChatScreen() {
  const { conversationId } = useLocalSearchParams();
  const { user } = useAuth();

  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState("");
  const [isLoading, setIsLoading] = useState(true);
  const [isSending, setIsSending] = useState(false);
  const [headerTitle, setHeaderTitle] = useState("Chat");
  const isMountedRef = useRef(true);

  useEffect(() => {
    isMountedRef.current = true;
    if (!conversationId || !user) return;

    let messageUnsubscribe = null;

    const initializeAndFetch = async () => {
      setIsLoading(true);
      try {
        const convDetails = await databases.getDocument(
          databaseId,
          conversationsCollectionId,
          conversationId
        );
        const participants = convDetails.participants;
        const otherParticipantId = participants.find((pId) => pId !== user.$id);
        if (otherParticipantId) {
          try {
            const profileResponse = await databases.listDocuments(
              databaseId,
              usersCollectionId,
              [Query.equal("userId", otherParticipantId), Query.limit(1)]
            );
            if (profileResponse.documents.length > 0 && isMountedRef.current) {
              setHeaderTitle(profileResponse.documents[0].name);
            }
          } catch (profileError) {
            console.error("Failed to fetch participant profile:", profileError);
            if (isMountedRef.current) setHeaderTitle("Chat");
          }
        } else if (isMountedRef.current) {
          setHeaderTitle("Yourself (Saved Messages)");
        }

        console.log("Fetching initial messages...");
        const messagesResponse = await databases.listDocuments(
          databaseId,
          messagesCollectionId,
          [
            Query.equal("conversationId", conversationId),
            Query.orderDesc("$createdAt"),
          ]
        );

        const plainMessages = messagesResponse.documents.map((doc) => ({
          id: doc.$id,
          senderId: doc.senderId,
          text: doc.text || "[Message content missing]",
          $createdAt: doc.$createdAt,
        }));

        if (isMountedRef.current) {
          setMessages(plainMessages);
        }
      } catch (error) {
        console.error("Failed to initialize chat screen:", error);
      } finally {
        if (isMountedRef.current) {
          setIsLoading(false);
        }
      }

      console.log("Setting up realtime subscription...");
      messageUnsubscribe = client.subscribe(
        `databases.${databaseId}.collections.${messagesCollectionId}.documents`,
        (response) => {
          if (
            response.events.includes(
              `databases.${databaseId}.collections.${messagesCollectionId}.documents.*.create`
            ) &&
            isMountedRef.current
          ) {
            const payload = response.payload;
            if (payload.conversationId === conversationId) {
              console.log("Realtime: Received new message:", payload.$id);
              if (messages.some((msg) => msg.id === payload.$id)) {
                console.log("Realtime: Message already exists, skipping.");
                return;
              }

              const newMessageData = {
                id: payload.$id,
                senderId: payload.senderId,
                text: payload.text || "[Message content missing]",
                $createdAt: payload.$createdAt,
              };
              setMessages((prevMessages) => [newMessageData, ...prevMessages]);
              console.log("Realtime: Plaintext message added.");
            }
          }
        }
      );
    };

    initializeAndFetch();

    return () => {
      isMountedRef.current = false;
      console.log("Cleaning up chat screen, unsubscribing...");
      if (messageUnsubscribe) {
        messageUnsubscribe();
      }
    };
  }, [conversationId, user]);

  const handleSendMessage = async () => {
    if (!newMessage.trim() || !user || !conversationId) return;

    setIsSending(true);
    const messageText = newMessage.trim();
    setNewMessage("");

    try {
      const messageData = {
        conversationId: conversationId,
        senderId: user.$id,
        text: messageText,
        sentAt: new Date().toISOString(),
      };

      console.log("Sending message document to Appwrite...");
      await databases.createDocument(
        databaseId,
        messagesCollectionId,
        ID.unique(),
        messageData
      );
      console.log("Message sent successfully.");

      await databases.updateDocument(
        databaseId,
        conversationsCollectionId,
        conversationId,
        {
          lastUpdatedAt: new Date().toISOString(),
          lastMessage: messageText,
        }
      );
    } catch (error) {
      console.error("Failed to send message:", error);
      Alert.alert("Send Error", "Could not send message.");
      setNewMessage(messageText);
    } finally {
      setIsSending(false);
    }
  };

  const renderItem = useCallback(
    ({ item }) => {
      const isMyMessage = item.senderId === user?.$id;
      return (
        <View
          className={`py-2 px-3 rounded-2xl mb-2 max-w-[80%] ${
            isMyMessage
              ? "bg-lime-100 self-end rounded-br-md"
              : "bg-white self-start rounded-bl-md"
          }`}
        >
          <Text className="text-base">{item.text}</Text>
        </View>
      );
    },
    [user]
  );

  return (
    <SafeAreaView
      className="flex-1 bg-stone-100"
      edges={["bottom", "left", "right"]}
    >
      <Stack.Screen
        options={{ title: headerTitle, headerBackTitle: "Chats" }}
      />

      {isLoading ? (
        <View className="flex-1 justify-center items-center">
          <ActivityIndicator size="large" />
        </View>
      ) : (
        <FlatList
          data={messages}
          renderItem={renderItem}
          keyExtractor={(item) => item.id}
          inverted
          contentContainerStyle={{ paddingHorizontal: 10, paddingTop: 10 }}
        />
      )}

      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        className="flex-row p-2.5 border-t border-gray-300 bg-white items-center"
        keyboardVerticalOffset={Platform.OS === "ios" ? 60 : 0}
      >
        <TextInput
          className="flex-1 min-h-[40px] bg-white rounded-full px-4 py-2.5 mr-2.5 border border-gray-300 text-base"
          style={{ maxHeight: 120 }}
          value={newMessage}
          onChangeText={setNewMessage}
          placeholder="Type a message..."
          multiline
        />
        <Button
          title="Send"
          onPress={handleSendMessage}
          disabled={isSending || !newMessage.trim()}
        />
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
}

================
File: app/index.js
================
import React, { useState, useEffect, useCallback } from "react";
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
  Button,
  ActivityIndicator,
} from "react-native";
import { Link, useRouter } from "expo-router";
import { SafeAreaView } from "react-native-safe-area-context";
import { useAuth } from "../context/AuthContext";
import {
  databases,
  databaseId,
  conversationsCollectionId,
  usersCollectionId,
} from "../lib/appwrite";
import { Query } from "appwrite";

// Define a named component for rendering list items
const ConversationItem = React.memo(({ item, user, userProfiles, onPress }) => {
  const otherParticipantNames = item.participants
    .filter((pId) => pId !== user?.$id)
    .map((pId) => userProfiles[pId] || `ID: ${pId.substring(0, 6)}...`)
    .join(", ");

  const displayName = otherParticipantNames || "Yourself (Saved Messages)";

  // console.log(`Rendering item: ${displayName}`); // Keep for debugging if needed

  return (
    <TouchableOpacity
      className="bg-white p-4 border-b border-gray-200"
      onPress={onPress}
    >
      <Text className="text-base font-bold mb-1">{displayName}</Text>
      <Text className="text-sm text-gray-600">
        {item.lastMessage || "No messages yet"}
      </Text>
    </TouchableOpacity>
  );
});
ConversationItem.displayName = "ConversationItem";

export default function ChatListScreen() {
  const { user, logout } = useAuth();
  const router = useRouter();
  const [conversations, setConversations] = useState([]);
  const [userProfiles, setUserProfiles] = useState({});
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    if (!user) return;

    let isMounted = true;

    const fetchConversationsAndProfiles = async () => {
      setIsLoading(true);
      let fetchedConversations = [];
      let participantIds = new Set();

      try {
        const response = await databases.listDocuments(
          databaseId,
          conversationsCollectionId,
          [
            Query.search("participants", user.$id),
            Query.orderDesc("lastUpdatedAt"),
          ]
        );
        fetchedConversations = response.documents;

        fetchedConversations.forEach((conv) => {
          conv.participants.forEach((pId) => {
            if (pId !== user.$id) {
              participantIds.add(pId);
            }
          });
        });

        if (participantIds.size > 0) {
          const profileResponse = await databases.listDocuments(
            databaseId,
            usersCollectionId,
            [Query.equal("userId", Array.from(participantIds))]
          );

          const profiles = {};
          profileResponse.documents.forEach((profile) => {
            profiles[profile.userId] = profile.name;
          });

          if (isMounted) {
            setUserProfiles(profiles);
          }
        }

        if (isMounted) {
          setConversations(fetchedConversations);
        }
      } catch (error) {
        console.error("Failed to fetch conversations or profiles:", error);
      } finally {
        if (isMounted) {
          setIsLoading(false);
        }
      }
    };

    fetchConversationsAndProfiles();

    // TODO: Set up Appwrite real-time subscription for conversation updates
    // Need to subscribe to conversation changes AND potentially user profile changes

    return () => {
      isMounted = false;
    };
  }, [user]);

  const handleSelectConversation = useCallback(
    (conversationId) => {
      router.push(`/chat/${conversationId}`);
    },
    [router]
  );

  // Use the named component in renderItem, wrapped in useCallback
  const renderItem = useCallback(
    ({ item }) => (
      <ConversationItem
        item={item}
        user={user}
        userProfiles={userProfiles}
        onPress={() => handleSelectConversation(item.$id)}
      />
    ),
    [user, userProfiles, handleSelectConversation]
  );

  if (!user) {
    return (
      <SafeAreaView className="flex-1 justify-center items-center">
        <Text>Please login.</Text>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView className="flex-1 bg-red-500">
      <View className="flex-row justify-between items-center px-4 py-4 border-b border-gray-200 bg-red-900">
        <Text className="text-2xl font-bold">Chats</Text>
        <View className="flex-row items-center space-x-2">
          <Link href="/test-style" asChild>
            <TouchableOpacity className="bg-yellow-500 px-3 py-1 rounded">
              <Text className="text-black text-xs">Test Style</Text>
            </TouchableOpacity>
          </Link>
          <Link href="/new-chat" asChild>
            <TouchableOpacity className="bg-indigo-500 px-4 py-2 rounded-lg active:bg-indigo-600">
              <Text className="text-white font-medium text-sm">New Chat</Text>
            </TouchableOpacity>
          </Link>
          <View className="ml-2">
            <Button title="Logout" onPress={logout} />
          </View>
        </View>
      </View>

      {isLoading ? (
        <View className="flex-1 justify-center items-center">
          <ActivityIndicator size="large" />
        </View>
      ) : (
        <FlatList
          data={conversations}
          renderItem={renderItem}
          keyExtractor={(item) => item.$id}
          ListEmptyComponent={
            <Text className="text-center mt-12 text-base text-gray-500">
              No conversations yet. Start a new chat!
            </Text>
          }
        />
      )}
    </SafeAreaView>
  );
}

================
File: app/new-chat.js
================
/* global setTimeout, clearTimeout */
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  TextInput,
  FlatList,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
} from "react-native";
import { Stack, useRouter } from "expo-router";
import { SafeAreaView } from "react-native-safe-area-context";
import { useAuth } from "../context/AuthContext";
import {
  databases,
  databaseId,
  usersCollectionId,
  conversationsCollectionId,
  messagesCollectionId,
} from "../lib/appwrite";
import { Query, ID } from "appwrite";
import { Permission, Role } from "appwrite";

export default function NewChatScreen() {
  const { user } = useAuth();
  const router = useRouter();
  const [searchQuery, setSearchQuery] = useState("");
  const [searchResults, setSearchResults] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isCreatingChat, setIsCreatingChat] = useState(false);

  // Debounced search effect
  useEffect(() => {
    const trimmedQuery = searchQuery.trim();
    if (!trimmedQuery) {
      setSearchResults([]);
      return;
    }

    const delayDebounceFn = setTimeout(async () => {
      if (!user) return;
      setIsLoading(true);
      try {
        const response = await databases.listDocuments(
          databaseId,
          usersCollectionId,
          [Query.search("name", trimmedQuery), Query.limit(25)]
        );

        // Re-enable self-filtering
        const filteredResults = response.documents.filter(
          (doc) => doc.userId !== user.$id
        );

        setSearchResults(filteredResults);
      } catch (error) {
        // Handle potential errors like index not ready or invalid query
        if (error.message.includes("search index")) {
          Alert.alert(
            "Search Error",
            "User search index might not be ready. Please wait a moment and try again."
          );
        } else {
          console.error("Search failed:", error);
          Alert.alert("Search Error", "Could not fetch users.");
        }
        setSearchResults([]); // Clear results on error
      } finally {
        setIsLoading(false);
      }
    }, 500); // 500ms debounce

    return () => clearTimeout(delayDebounceFn);
  }, [searchQuery, user]);

  const handleSelectUser = async (selectedUser) => {
    if (!user || isCreatingChat) return;
    setIsCreatingChat(true);

    const currentUser = user;
    const otherUser = selectedUser;

    console.log(
      "Initiating chat between:",
      currentUser.$id,
      "and:",
      otherUser.userId
    );

    try {
      // Check if a 1-on-1 conversation already exists
      const q1 = Query.search("participants", currentUser.$id);
      const q2 = Query.search("participants", otherUser.userId);
      const existingConversations = await databases.listDocuments(
        databaseId,
        conversationsCollectionId,
        [q1, q2]
      );
      const existingChat = existingConversations.documents.find(
        (doc) =>
          doc.participants.length === 2 &&
          doc.participants.includes(currentUser.$id) &&
          doc.participants.includes(otherUser.userId)
      );

      if (existingChat) {
        console.log("Existing chat found:", existingChat.$id);
        router.push(`/chat/${existingChat.$id}`);
      } else {
        console.log("No existing chat found. Creating new one...");

        // Create conversation document without DR fields
        console.log("Attempting to create conversation document...");
        const newConversation = await databases.createDocument(
          databaseId,
          conversationsCollectionId,
          ID.unique(),
          {
            participants: [currentUser.$id, otherUser.userId],
            lastMessage: null,
            lastUpdatedAt: new Date().toISOString(),
          },
          [
            Permission.read(Role.user(currentUser.$id)),
            Permission.update(Role.user(currentUser.$id)),
            Permission.read(Role.user(otherUser.userId)),
            Permission.update(Role.user(otherUser.userId)),
          ]
        );
        console.log("Conversation document created:", newConversation.$id);

        router.push(`/chat/${newConversation.$id}`);
      }
    } catch (error) {
      console.error("Failed to start chat:", error);
      Alert.alert("Error", `Could not start chat. ${error.message}`);
    } finally {
      setIsCreatingChat(false);
    }
  };

  const renderItem = ({ item }) => (
    <TouchableOpacity
      className="p-4 border-b border-gray-200"
      onPress={() => handleSelectUser(item)}
      disabled={isCreatingChat}
    >
      <Text className="text-base font-bold">{item.name || "No Name"}</Text>
      <Text className="text-sm text-gray-500">{item.email}</Text>
    </TouchableOpacity>
  );

  return (
    <SafeAreaView className="flex-1 bg-white">
      <Stack.Screen options={{ title: "New Chat" }} />
      <View className="p-2.5 border-b border-gray-200">
        <TextInput
          className="h-10 border border-gray-300 rounded px-2.5 bg-gray-100"
          placeholder="Search by name or email..."
          value={searchQuery}
          onChangeText={setSearchQuery}
          autoCapitalize="none"
        />
      </View>

      {isLoading && <ActivityIndicator className="mt-5" />}

      <FlatList
        data={searchResults}
        renderItem={renderItem}
        keyExtractor={(item) => item.userId}
        ListEmptyComponent={
          !isLoading && searchQuery.trim() ? (
            <Text className="text-center mt-12 text-base text-gray-500">
              No users found.
            </Text>
          ) : null
        }
      />
      {isCreatingChat && <ActivityIndicator className="my-2.5" />}
    </SafeAreaView>
  );
}

================
File: app/test-style.js
================
import React from "react";
import { View, Text } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { Stack } from "expo-router";

export default function TestStyleScreen() {
  return (
    // Use SafeAreaView edges if needed, apply obvious background
    <SafeAreaView className="flex-1 items-center justify-center bg-purple-500">
      <Stack.Screen options={{ title: "Style Test" }} />
      <Text className="text-white text-2xl font-bold p-5 bg-black/50 rounded-lg">
        If you see a purple background and white text, NativeWind is working!
      </Text>
    </SafeAreaView>
  );
}

================
File: babel.config.js
================
module.exports = function (api) {
  api.cache(true);
  return {
    presets: [
      ["babel-preset-expo", { jsxImportSource: "nativewind" }],
      "nativewind/babel",
    ],
    plugins: [
      [
        "module:react-native-dotenv",
        {
          moduleName: "@env",
          path: ".env",
        },
      ],
    ],
  };
};

================
File: context/AuthContext.js
================
/* global setTimeout */
import React, {
  createContext,
  useState,
  useContext,
  useEffect,
  useCallback,
} from "react";
import {
  account,
  databases,
  databaseId,
  usersCollectionId,
} from "../lib/appwrite"; // Import Appwrite account service
import { ID, Query } from "appwrite";
import { Alert } from "react-native";
import { router } from "expo-router";

const AuthContext = createContext(null);

export const useAuth = () => useContext(AuthContext);

// Function to introduce a delay
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [appwriteUserDoc, setAppwriteUserDoc] = useState(null); // Store user profile doc

  // Function to check if user is logged in
  const checkLogin = useCallback(async () => {
    setIsLoading(true);
    try {
      const currentUser = await account.get();
      if (currentUser) {
        setUser(currentUser);
        // Fetch the corresponding user document from the database
        const userDocResponse = await databases.listDocuments(
          databaseId,
          usersCollectionId,
          [Query.equal("userId", currentUser.$id)]
        );
        if (userDocResponse.documents.length > 0) {
          setAppwriteUserDoc(userDocResponse.documents[0]);
        } else {
          console.error("Appwrite user document not found for logged in user!");
          setAppwriteUserDoc(null); // Ensure state is cleared
        }
      } else {
        setUser(null);
        setAppwriteUserDoc(null);
      }
    } catch (error) {
      // Handle the case where there's no active session (expected on first load)
      if (error.message.includes("User (role: guests)")) {
        console.log("No active session found.");
      } else {
        console.error("Check login error:", error);
      }
      setUser(null);
      setAppwriteUserDoc(null);
    } finally {
      setIsLoading(false);
    }
  }, []);

  const login = async (email, password) => {
    setIsLoading(true); // Set loading true at the start
    try {
      await account.createEmailPasswordSession(email, password);
      // Now checkLogin just fetches user and doc, no Signal setup effect
      await checkLogin();
      console.log("Login successful, navigating to home.");
      router.replace("/home");
      return { success: true }; // Indicate success
    } catch (error) {
      console.error("Login failed:", error);
      Alert.alert("Login Failed", error.message);
      setUser(null); // Clear user state on failure
      setAppwriteUserDoc(null); // Clear doc state on failure
      setIsLoading(false); // Ensure loading is false on failure
      return { success: false, error }; // Indicate failure
    }
  };

  const signup = async (email, password, name) => {
    setIsLoading(true);
    let newAccount = null; // Define newAccount outside try to potentially use in catch for cleanup
    try {
      // 1. Create Appwrite account
      newAccount = await account.create(ID.unique(), email, password, name);
      const newUserId = newAccount.$id; // Use a clearer variable name
      console.log("Appwrite account created:", newUserId);

      // 2. Log in the new user
      await account.createEmailPasswordSession(email, password);
      console.log("Logged in new user.");

      // Fetch the session user object (might differ slightly from create result)
      const currentUser = await account.get();
      setUser(currentUser); // Set user state immediately after login

      // 3. Create user profile document in the database
      console.log("Creating user profile document...");
      const profileDoc = await databases.createDocument(
        databaseId,
        usersCollectionId,
        ID.unique(), // Use a unique ID for the document itself
        {
          userId: newUserId,
          email: email,
          name: name || email.split("@")[0], // Use name or derive from email
          // Removed Signal fields
          // publicIdentityKey: null,
          // registrationId: null,
          // signedPreKey: null,
          // preKeys: null,
        }
      );
      console.log("User profile document created:", profileDoc.$id);
      setAppwriteUserDoc(profileDoc); // Set the document state

      // No Signal setup effect needed anymore

      Alert.alert("Signup Successful", "Account created and logged in!");
      router.replace("/home");
      return { success: true };
    } catch (error) {
      console.error("Signup failed:", error);
      Alert.alert("Signup Failed", error.message);
      // Cleanup attempts (optional, depends on error type)
      // if (newAccount) { /* maybe try deleting the account if doc creation failed? */ }
      setUser(null); // Reset state
      setAppwriteUserDoc(null); // Reset state
      setIsLoading(false); // Ensure loading is false on failure
      return { success: false, error };
    }
  };

  const logout = async () => {
    setIsLoading(true);
    try {
      await account.deleteSession("current");
      setUser(null);
      setAppwriteUserDoc(null);
      // No SignalStore cleanup needed
      console.log("Logout successful.");
      router.replace("/sign-in");
    } catch (error) {
      console.error("Logout failed:", error);
      Alert.alert("Logout Failed", error.message);
    } finally {
      setIsLoading(false);
    }
  };

  // Test connection - useful for debugging setup issues
  const testAppwriteConnection = async () => {
    try {
      await account.get(); // Try getting the current user
      return {
        success: true,
        message: "Connection successful (found active session).",
      };
    } catch (error) {
      // If error indicates guest status, connection is still OK (endpoint reachable)
      if (error.message.includes("User (role: guests)")) {
        return {
          success: true,
          message:
            "Connection successful (no active session). Endpoint/Project ID OK.",
        };
      }
      // If project ID is wrong
      else if (
        error.message.includes(
          "Project with the requested ID could not be found"
        )
      ) {
        return {
          success: false,
          message: `Connection Failed: Project not found. Check Endpoint/Project ID in .env and restart bundler. Error: ${error.message}`,
        };
      }
      // Other errors
      else {
        return {
          success: false,
          message: `Connection Failed: ${error.message}`,
        };
      }
    }
  };

  // Check login status on initial mount
  useEffect(() => {
    console.log("AuthProvider mounted, checking initial login status...");
    checkLogin();
  }, [checkLogin]); // Run only on mount/checkLogin change

  return (
    <AuthContext.Provider
      value={{
        user,
        appwriteUserDoc,
        isLoading,
        login,
        signup,
        logout,
        testAppwriteConnection,
        refetchUserDoc: checkLogin, // Allow components to refetch user/doc easily
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

================
File: globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

================
File: index.js
================
// START INSERT: Required polyfills/imports for signal-protocol-react-native
// import "react-native-get-random-values"; // Removed - Reverting Signal changes
// import 'react-native-securerandom';
// import 'expo-random';
// import 'isomorphic-webcrypto';
// END INSERT

// import { Buffer } from "buffer"; // Removed - Reverting Signal changes
// global.Buffer = Buffer; // Removed - Reverting Signal changes

import { registerRootComponent } from "expo";

import App from "./App";

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);

================
File: lib/appwrite.js
================
import { Client, Account, Databases } from "react-native-appwrite"; // Use the correct SDK
import {
  APPWRITE_ENDPOINT,
  APPWRITE_PROJECT_ID,
  APPWRITE_DATABASE_ID as envDatabaseId,
  APPWRITE_USERS_COLLECTION_ID as envUsersCollectionId,
  APPWRITE_CONVERSATIONS_COLLECTION_ID as envConversationsCollectionId,
  APPWRITE_MESSAGES_COLLECTION_ID as envMessagesCollectionId,
  APPWRITE_PLATFORM,
  // eslint-disable-next-line import/no-unresolved
} from "@env";

if (
  !APPWRITE_ENDPOINT ||
  !APPWRITE_PROJECT_ID ||
  !envDatabaseId ||
  !envUsersCollectionId ||
  !envConversationsCollectionId ||
  !envMessagesCollectionId ||
  !APPWRITE_PLATFORM
) {
  throw new Error(
    "Missing Appwrite environment variables (Endpoint, Project ID, Database ID, Platform ID, or Collection IDs). Did you create/update .env and restart the bundler?"
  );
}

const client = new Client()
  .setEndpoint(APPWRITE_ENDPOINT)
  .setProject(APPWRITE_PROJECT_ID)
  .setPlatform(APPWRITE_PLATFORM);

const account = new Account(client);
const databases = new Databases(client);

// Assign to local constants
const databaseId = envDatabaseId;
const usersCollectionId = envUsersCollectionId;
const conversationsCollectionId = envConversationsCollectionId;
const messagesCollectionId = envMessagesCollectionId;

// Export the local constants
export {
  client,
  account,
  databases,
  databaseId,
  usersCollectionId,
  conversationsCollectionId,
  messagesCollectionId,
};

================
File: metro.config.js
================
const { getDefaultConfig } = require("expo/metro-config");
const { withNativeWind } = require("nativewind/metro");

const config = getDefaultConfig(__dirname);

// Removed resolver config for Node module polyfills

module.exports = withNativeWind(config, { input: "./globals.css" });

// Removed comment about helper dependencies

================
File: package.json
================
{
  "name": "dds_chatapp",
  "version": "1.0.0",
  "main": "expo-router/entry",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "lint": "eslint ."
  },
  "dependencies": {
    "@react-native-community/masked-view": "^0.1.11",
    "appwrite": "^17.0.2",
    "buffer": "^6.0.3",
    "expo": "~52.0.43",
    "expo-constants": "~17.0.8",
    "expo-linking": "~7.0.5",
    "expo-router": "~4.0.20",
    "expo-secure-store": "~14.0.1",
    "expo-status-bar": "~2.0.1",
    "nativewind": "^4.1.23",
    "react": "18.3.1",
    "react-native": "0.76.9",
    "react-native-appwrite": "^0.7.3",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-get-random-values": "^1.11.0",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-url-polyfill": "^2.0.0",
    "react-navigation": "^5.0.0",
    "signal-protocol-react-native": "^0.1.13",
    "tailwindcss": "^3.4.17"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "eslint": "^8.57.0",
    "eslint-config-expo": "~8.0.1",
    "react-native-dotenv": "^3.4.11"
  },
  "private": true
}

================
File: plan.md
================
# Secure Chat App Development Plan

## Phase 1: Project Setup & Foundation

- [x] **Initialize Expo Project:** Set up a new Expo project with a JavaScript template.
- [x] **Install Dependencies:**
  - [x] `nativewind`, `tailwindcss`
  - [x] `appwrite`
  - [x] `expo-router`, `react-native-screens`, `react-native-safe-area-context`, `expo-linking`, `expo-constants`, `expo-status-bar`
  - [x] ~~`@privacyresearch/libsignal-protocol-typescript`~~ (Removed due to bundling issues)
  - [x] `expo-secure-store`
  - [x] `react-native-dotenv` (for environment variables)
  - [x] `buffer` (polyfill attempt)
  - [x] `react-native-get-random-values` (polyfill attempt)
- [x] **Configure NativeWind:** Setup complete.
- [x] **Basic Structure:** Created core directories (`app`, `components`, `utils`, `lib`, `context`).
- [x] **Setup Navigation:** Migrated from React Navigation to file-based routing with Expo Router (`app/_layout.js`, `app/index.js`).

## Phase 2: Authentication

- [x] **Appwrite Setup:** Created Appwrite project, configured platforms (Android, iOS), stored Project ID, Endpoint, Platform ID in `.env`.
- [x] **Create Auth Screens:** Built UI for `LoginScreen` and `SignupScreen` (`app/(auth)/login.js`, `app/(auth)/sign-up.js`).
- [x] **Implement Auth Logic:** Integrated Appwrite SDK for account creation, login, logout using `react-native-appwrite` SDK (`lib/appwrite.js`, `context/AuthContext.js`). Added connection test function.
- [x] **Session Management:** Implemented session persistence (via `account.get()`) and conditional navigation using React Context and Expo Router layout effects (`context/AuthContext.js`, `app/_layout.js`).

## Phase 3: Core Chat Functionality (Unencrypted)

- [x] **Appwrite Database Setup:** Designed and created collections with attributes and permissions (See Appendix A).
- [x] **Chat List Screen:** Created `ChatListScreen` (`app/index.js`) fetching conversations.
- [x] **Chat Screen:** Created `ChatScreen` (`app/chat/[conversationId].js`) displaying messages, sending new messages, and basic realtime message subscription.
- [x] **Message Sending Enhancements:** Updated conversation `lastMessage` and `lastUpdatedAt` on send.
- [x] **Chat List Screen Enhancements:** Fetched and displayed participant names from `users` collection.
- [x] **Chat Screen Enhancements:** Fetched participant profile and displayed name in header.
- [x] **New Chat Flow:** Implemented user search (`Query.search` on indexed `name`) and 1-on-1 conversation creation/navigation (`app/new-chat.js`).
- [x] **User Profile Creation:** Created user profile document in `users` collection on signup.
- [ ] **Real-time Updates Refinement:** Basic message realtime implemented. Conversation list realtime updates TBD.

## Phase 4: Double Ratchet E2EE Implementation

- **Library Selection Issues (Summary):**

  - Attempted to use `@privacyresearch/libsignal-protocol-typescript`.
  - Encountered `RangeError: Unknown encoding: utf-16le` during Metro bundling, even when library functions were not called.
  - Attempted polyfilling Node.js modules (`crypto`, `stream`, `vm`, `buffer`) using `react-native-crypto`, `stream-browserify`, `vm-browserify`, `node-libs-react-native` and Metro config (`resolver.extraNodeModules`).
  - Polyfilling did not resolve the bundling error.
  - **Conclusion:** Library seems incompatible with the React Native/Expo/Metro environment in its current state. Changes reverted.
  - **Next Step:** Need to find an alternative, React Native-compatible library for the Signal Protocol / Double Ratchet algorithm.

- [ ] **Select Compatible Library:** Research and choose a suitable library.
- [ ] **Key Management:**
  - [ ] Generate identity key pairs.
  - [ ] Generate signed prekeys and one-time prekeys.
  - [ ] Store public keys in Appwrite (`users` collection attributes TBD based on library).
  - [ ] Store private keys securely on device (`expo-secure-store`).
- [ ] **Session Establishment:**
  - [ ] Fetch recipient's public key bundle from Appwrite.
  - [ ] Establish initial Signal Protocol session using chosen library.
- [ ] **Encryption/Decryption:**
  - [ ] Encrypt messages before sending to Appwrite.
  - [ ] Decrypt messages received from Appwrite.
  - [ ] Handle ratchet progression.
- [ ] **PreKey Management:** Manage and replenish one-time prekeys.

## Phase 5: Contact Management & Refinements

- [/] **User Discovery:** Basic user search implemented in `app/new-chat.js`. Further refinement might be needed.
- [ ] **Contact List:** Allow adding and displaying contacts explicitly.
- [ ] **UI/UX Polish:** Refine UI, add loading states, error handling.
- [ ] **Optional Features:** Consider typing indicators, read receipts, profiles, etc.

## Phase 6: Testing & Deployment

- [ ] **Testing:** Unit tests, integration tests, manual testing.
- [ ] **Build & Deployment:** Use EAS Build for iOS/Android, prepare for app store submission.

---

## Appendix A: Appwrite Database Schema (chat_db)

_(Note: Database ID stored in `.env` as `APPWRITE_DATABASE_ID`)_
_(Note: Collection IDs stored in `.env`)_
_(Note: Document Security MUST be enabled for all collections)_

**1. `users` Collection**

- Purpose: Stores user profile information linked to Auth user.
- Attributes:
  - `userId` (String, Required, Size: 255) - Appwrite Auth User ID (`$id`). Indexed.
  - `name` (String, Required, Size: 255) - User display name. Fulltext Indexed.
  - `email` (String, Required, Size: 255, Format: Email) - User email. Fulltext Indexed.
  - `identityKey` (String, Optional, Size: 512) - Base64 encoded public identity key.
  - `registrationId` (Integer, Optional) - Signal registration ID.
  - _(Potentially add pre-key bundle attributes here later)_
- Collection Permissions:
  - Read: `All users` (`role:member`)
  - Create: `All users` (`role:member`)
  - Update: _(None - Use Document Level)_
  - Delete: _(None - Use Document Level)_
- Document Permissions:
  - Read: `All users` (`role:member`)
  - Update: `user:{userId}`
  - Delete: `user:{userId}`

**2. `conversations` Collection**

- Purpose: Represents a chat session between participants.
- Attributes:
  - `participants` (String[], Required, Size: 100) - Array of participant `userId`s. Indexed.
  - `lastMessage` (String, Optional, Size: 1024) - Text of the last message (for preview).
  - `lastUpdatedAt` (DateTime, Optional) - Timestamp of the last message/activity. Indexed.
- Collection Permissions:
  - Read: `All users` (`role:member`)
  - Create: `All users` (`role:member`)
  - Update: _(None - Use Document Level)_
  - Delete: _(None - Use Document Level)_
- Document Permissions:
  - Read: `user:{participants}`
  - Update: `user:{participants}`
  - Delete: _(None - Decide if needed)_

**3. `messages` Collection**

- Purpose: Stores individual chat messages.
- Attributes:
  - `conversationId` (String, Required, Size: 255) - ID of the parent conversation. Indexed.
  - `senderId` (String, Required, Size: 255) - `userId` of the message sender. Indexed.
  - `text` (String, Required, Size: 4096) - Message content (will be encrypted).
  - `sentAt` (DateTime, Required) - Timestamp message was sent by client. Indexed.
- Collection Permissions:
  - Read: `All users` (`role:member`)
  - Create: `All users` (`role:member`)
  - Update: _(None - Use Document Level)_
  - Delete: _(None - Use Document Level)_
- Document Permissions:
  - Read: `user:{senderId}` _(Consider if recipients also need direct read access here, or rely on querying by conversation)_
  - Update: `user:{senderId}` _(Optional)_
  - Delete: `user:{senderId}` _(Optional)_

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  // Ensure paths cover all files using Tailwind classes
  content: [
    "./app/**/*.{js,jsx,ts,tsx}",
    "./context/**/*.{js,jsx,ts,tsx}",
    "./components/**/*.{js,jsx,ts,tsx}", // Add if you have a components folder
    "./*.{js,jsx,ts,tsx}",
  ],
  presets: [require("nativewind/preset")],
  theme: {
    extend: {},
  },
  plugins: [],
};
